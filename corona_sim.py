#!/usr/bin/env python3
# encoding=utf8

"""
We will assume that the daily interaction patterns of residents in a city are normally distributed
from 1 to 2x mean. i.e. if mean is set to be 25, we assume that the average number of interactions
for a person is 25 and distributed between 1 and 50 (a very few people will have interactions more
than 50 - we will allow it - but no interactions less than 1 obviously because someone completely
isolated can't catch the virus and is not relevant to the model).

Now each person's state is denoted by the following data structure:
    {id: int,
    avg_interactions: int, drawn from above distribution,
    day_interactions: int, count up until n_interactions and reset to 0 at the end of each day
    has_virus: boolean,
    day_infected: int, the day when the infection happened,
    }
"""
import argparse
import matplotlib.pyplot as plt
import numpy as np
import pandas as pd

parser = argparse.ArgumentParser(formatter_class=argparse.ArgumentDefaultsHelpFormatter)
parser.add_argument('n_population', help='Size of the population', type=int)
parser.add_argument('mean_interactions', help='Avg number of interactions for each individual per day', type=int)
parser.add_argument('-d', '--max_days_to_simulate', default=365, help='We\'ll stop if everyone is healthy before then', type=int)
parser.add_argument('-bh', '--beds_hospital', default=500, help='Number of hospital beds', type=int)
parser.add_argument('-bi', '--beds_icu', default=50, help='Number of ICU beds', type=int)
parser.add_argument('-vl', '--virus_latent', default=14, help='Days virus is latent (no symptoms)', type=int)
parser.add_argument('-va', '--virus_active', default=14, help='Days virus is active after latency and before recovery', type=int)
parser.add_argument('-pt', '--p_transmission', default=.01, help='Probability that an interaction will result in transmission', type=float)
parser.add_argument('-ph', '--hospital_percentage', default=0.2, help='Probability that an infected person will need hospitalization', type=float)
parser.add_argument('-pi', '--icu_percentage', default=0.05, help='Probability that an infected person will need hospitalization', type=float)
parser.add_argument('-dp', '--death_percentage', default=0.02, help='Probability that an infected person will die', type=float)
parser.add_argument('-m', '--shortage_multiplier', default=4, help='Chance of escalation if someone needing hospital/ICU can\'t get it', type=float)
parser.add_argument('-o', '--output_file', help='Output filename (no extension - autogenerated if not supplied. If it begins with _ then used as suffix', type=str)
args=parser.parse_args()

print('Running simlation with the following parameters:')
for arg in vars(args):
    print('{:>40} : {}'.format(arg, vars(args)[arg]))

# Population and infrastructure
n_population = args.n_population
mean_interactions = args.mean_interactions
max_days_to_simulate = args.max_days_to_simulate  # We'll stop if everyone is healthy before this date
beds_hospital = args.beds_hospital
beds_icu = args.beds_icu

# Disease characteristics
virus_latent = args.virus_latent            # First n days. One carries and spreads the virus but no symptoms
virus_active = args.virus_active            # Symptoms last m days. Treatment - but one stops spreading the virus
p_transmission = args.p_transmission        # The probability that an encounter will result in transmission
hospital_percentage = args.hospital_percentage
icu_percentage = args.icu_percentage
death_percentage = args.death_percentage
shortage_multiplier = args.shortage_multiplier      # If someone needing hospital or ICU care can't get it, this is the factor
                                                    # by which their chance of escalation goes up


################################################################################
# A function which simulates a single encounter between two people
def encounter(p1, p2):
    # Increment interaction counts
    p1['day_interactions'] += 1
    p2['day_interactions'] += 1
    # Is either person infected
    if p1['has_virus'] != p2['has_virus']:
        if np.random.random() < p_transmission:
            if p1['has_virus'] and p1['day_infected'] < day:
                p2['has_virus'] = True
                p2['day_infected'] = day
            elif p2['day_infected'] < day:
                p1['has_virus'] = True
                p1['day_infected'] = day

    # from the list of indices. They've done their daily interactions.
    return (p1['day_interactions']>=p1['avg_interactions'], p2['day_interactions']>=p2['avg_interactions'])

def print_pop(pop):
    lpop = pop.copy()
    lpop = sorted(pop, key=lambda x: population[x]['avg_interactions'])
    for lp in lpop:
        print('{:>3} {:>3} {:>3} {}'.format(lp, population[lp]['avg_interactions'], population[lp]['day_interactions'], ''.join(['*']*population[lp]['day_interactions'])))


################################################################################
# Set up pools to hold different categories of people
# The master list is population. pop_index is going to track people who are healthy
# or not yet shwing symptoms. i.e. people still interacting with others.
# Of the following sets, sick_index, recovered_index and dead_index along with
# pop_index make up the entire population and are mutually exclusive.
# Hospital_index and icu_index are subsets of sick_index.
sick_index = []
hospital_index = [] # is a subset of sick index
icu_index = []      # is a subset of sick index
dead_index = []     # only icu patients may die, remove them from the pool
recovered_index = []
data_table = []     # Will contain day by day results

# We begin by setting up a population dataset - min_interactions can't be less than 1
population = np.random.normal(mean_interactions, mean_interactions/3, n_population)
population = [{'id': i, 'avg_interactions':(int(p), 1)[p < 1], 'day_interactions':0, \
               'has_virus': False, 'day_infected': 0} for i, p in enumerate(population)]
pop_index = list(range(len(population)))

# No one has the disease. Now select a random person above and introduce the disease. This is day 1!
i = np.random.choice(pop_index)
population[i]['has_virus']=True
population[i]['day_infected']=1

print('Patient zero\'s mean daily interactions: {}'.format(population[i]['avg_interactions']))


# Print report for day 1
data_table.append({'day': 1, 'healthy': len(pop_index)-1,'infected': 1, 'sick': 0, 'hospital': 0,  'icu': 0, 'dead': 0, 'recovered': 0})
print('{:>3} | {:>7} | {:>8} | {:>4} | {:>8} | {:>4} | {:>4} | {:9}' \
      .format('Day', 'Healthy', 'Infected', 'Sick', 'Hospital', 'ICU', 'Dead', 'Recovered'))
print('{:>3} | {:>7} | {:>8} | {:>4} | {:>8} | {:>4} | {:>4} | {:9}' \
      .format(1, len(pop_index)-1, 1, 0, 0, 0, 0, 0))

# Simulate days
inf = i
inf_no = 0
for day in range(2, max_days_to_simulate+1):
    infected_count = 0
    interactions_done = []
    while len(pop_index) > 1:
        i1, i2 = sorted(np.random.choice(range(len(pop_index)), 2, replace=False), reverse=True)
        if i1==inf or i2==inf:
            inf_no+=1
        p1 = pop_index[i1]
        p2 = pop_index[i2]
        b1, b2 = encounter(population[p1], population[p2])
        if b1:
            interactions_done.append(pop_index.pop(i1))
        if b2:
            interactions_done.append(pop_index.pop(i2))

    # Reconstitute the pool at the end of the day
    pop_index = interactions_done + pop_index

    # At the end of each day, reset day_interactions, count the infected, move the sick out of the pool
    for i, pi in enumerate(pop_index):
        population[pi]['day_interactions'] = 0
        if population[pi]['has_virus']:
            if day-population[pi]['day_infected'] <= virus_latent:
                infected_count +=1
            else:
                sick_index.append(pop_index.pop(i))

    # For the sick, figure out whether they end up in hospital (day 1 of active)
    # or whether they've recovered (latent+active reached).
    for si in sick_index:
        if day-population[si]['day_infected'] == virus_latent+1:
            # Does this person end up in hospital?
            if np.random.random() <= hospital_percentage:
                hospital_index.append(si)
        elif day-population[si]['day_infected'] >= virus_latent+virus_active:
            recovered_index.append(si)
    # Remove all the recovered people from the sick pool
    sick_index = list(set(sick_index) - set(recovered_index))
    hospital_index = list(set(hospital_index) - set(recovered_index))
    icu_index = list(set(icu_index) - set(recovered_index))

    # For the hospitalized, figure out whether they end up in ICU (3rd of way into active period)
    # If a person needs to be hospitalized but there are no beds, then their chance to end up in icu spikes
    for i, hi in enumerate(hospital_index):
        if day-population[hi]['day_infected'] == virus_latent+int(virus_active/3):
            if np.random.random() < icu_percentage * (shortage_multiplier if len(hospital_index)>beds_hospital else 1):
                icu_index.append(hospital_index.pop(i))

    # For ICU, figure out if anyone dies. People in the last third of the virus_active period
    # If a person needs to be hospitalized but there are no beds, then their chance to end up in icu spikes
    for i, ii in enumerate(icu_index):
        if day-population[ii]['day_infected'] == virus_latent+int(virus_active*2/3):
            if np.random.random() < (death_percentage/icu_percentage) * (shortage_multiplier if len(icu_index)>beds_icu else 1):
                dead_index.append(icu_index.pop(i))
    # Remove the dead from the sick pool, they should already have been removed from hospital and icu
    sick_index = list(set(sick_index) - set(dead_index))

    # Compile the data
    data = {\
     'day': day, \
     'healthy': len(pop_index)-infected_count, \
     'infected': infected_count,\
     'sick': len(sick_index), \
     'hospital': len(hospital_index), \
     'icu': len(icu_index), \
     'dead': len(dead_index), \
     'recovered': len(recovered_index) \
     }
    data_table.append(data)

    print('{:>3} | {:>7} | {:>8} | {:>4} | {:>8} | {:>4} | {:>4} | {:9}' \
              .format(data['day'], data['healthy'], data['infected'], \
                     data['sick'], data['hospital'], data['icu'], data['dead'], data['recovered']))

    # Stop if no one is sick, but only after running at least a month
    if len(recovered_index)+ len(dead_index) + (0, len(pop_index))[day>30] == len(population):
        break


# Build and save dataframe
df = pd.DataFrame(data_table)
file_name = 'covid_sim_pop_{}_mean_{}_hosp_{}_icu_{}'.format(len(population), mean_interactions, beds_hospital, beds_icu)
if args.output_file:
    if args.output_file[0] == '_':
        file_name += args.output_file
    else:
        file_name = args.output_file
df.to_csv(file_name+'.csv')


# Draw the plot
# We take the subsets out of 'sick'
df['sick'] = df['sick'] - df['hospital'] - df['icu']
x = list(df['day'])

plt.figure(figsize=(15,8))
plt.xlim(0,len(x))
plt.xlabel('Days since first case')
plt.ylabel('No. of people')
plt.title('Simulation run for {} people, {} mean interactions per day. {} hospital beds, {} ICU beds. {} deaths.'\
          .format(len(population), mean_interactions, beds_hospital, beds_icu, len(dead_index)))

stack = ['ICU', 'Hospital', 'Sick', 'Infected', 'Healthy', 'Recovered','Dead']
bottom = [0]*len(x)

colors = ['#b30000', '#e34a33', '#fc8d59', '#fdcc8a','#2b8cbe', '#a6bddb','#ff0000']
for i, layer in enumerate(stack):
    plt.bar(x, df[layer.lower()], bottom=bottom, width=1, color=colors[i], label=stack[i])
    bottom+=df[layer.lower()]
plt.plot([0,len(x)], [beds_hospital+beds_icu, beds_hospital+beds_icu], alpha=.5)
plt.plot([0,len(x)], [beds_icu, beds_icu], alpha=.5)
plt.text(int(x[-1]*.02), int(len(population)*.01)+beds_hospital+beds_icu, 'Hospital Beds')
plt.legend(ncol=2, loc='upper left')
plt.savefig(file_name+'.png')